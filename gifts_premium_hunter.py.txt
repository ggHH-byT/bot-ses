import asyncio, os, re, json, logging, signal, random
from pathlib import Path
from typing import Optional

from dotenv import load_dotenv
from telethon import TelegramClient
from playwright.async_api import async_playwright, Page, Frame

load_dotenv()

API_ID = int(os.getenv("TG_API_ID"))
API_HASH = os.getenv("TG_API_HASH")
SESSION = os.getenv("SESSION_NAME", "user_gifts_session")

CHECK_INTERVAL = int(os.getenv("CHECK_INTERVAL", "60"))           # —Å–µ–∫—É–Ω–¥ –º–µ–∂–¥—É —Ü–∏–∫–ª–∞–º–∏
MAX_BUYS_PER_CYCLE = int(os.getenv("MAX_BUYS_PER_CYCLE", "5"))    # –ø–æ–∫—É–ø–æ–∫ –∑–∞ —Ü–∏–∫–ª
PREMIUM_WORDS = [w.strip().lower() for w in os.getenv("PREMIUM_WORDS", "premium,–ø—Ä–µ–º–∏—É–º").split(",")]
NEW_NOTIFY_LIMIT = int(os.getenv("NEW_NOTIFY_LIMIT", "20"))
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()

STORAGE = "tg_storage_state.json"     # playwright: —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–µ—Å—Å–∏–∏ Telegram Web
BOUGHT_FILE = Path("bought_titles.json")
SEEN_FILE = Path("seen_gifts.json")   # <‚Äî –≤—Å–µ —É–∂–µ –≤—Å—Ç—Ä–µ—á–µ–Ω–Ω—ã–µ –∫–∞—Ä—Ç–æ—á–∫–∏ (–¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ –Ω–æ–≤—ã—Ö)

logging.basicConfig(level=getattr(logging, LOG_LEVEL, logging.INFO),
                    format="%(asctime)s %(levelname)s: %(message)s")
LOG = logging.getLogger("gifts")

# ===== –°–µ–ª–µ–∫—Ç–æ—Ä—ã =====
ENTRY_SEND_GIFT = "button:has-text('–û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–¥–∞—Ä–æ–∫'), button:has-text('Send a gift')"
ENTRY_SEND_TO_SELF = "button:has-text('–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–µ–±–µ'), button:has-text('Send to myself')"

ALL_TAB = "button:has-text('–í—Å–µ –ø–æ–¥–∞—Ä–∫–∏'), button:has-text('All gifts')"

CARD_ITEM = "[data-test-id='gift-card'], .gift-card, [class*='giftCard'], [class*='GiftCard']"
CARD_TITLE = ".title, [data-test-id='gift-title'], [class*='Title']"
CARD_BADGE = ".badge, .label, [data-test-id='gift-badge'], [class*='Badge']"
CARD_FRAME = ".card, .frame, .container, [class*='card']"

BUY_BTN_LIST = ("button:has-text('–ö—É–ø–∏—Ç—å'), button:has-text('Buy'), "
                "button:has-text('–û—Ç–ø—Ä–∞–≤–∏—Ç—å'), button:has-text('Send')")
CONFIRM_BUY_BTN = ("button:has-text('–û–¢–ü–†–ê–í–ò–¢–¨ –ü–û–î–ê–†–û–ö'), "
                   "button:has-text('–û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–¥–∞—Ä–æ–∫'), button:has-text('Send gift')")

GIFT_ENTRY_URL = "https://t.me/gifts"

# ===== –£—Ç–∏–ª—å =====
def _load_set(file: Path) -> set:
    if file.exists():
        try:
            return set(json.loads(file.read_text("utf-8")))
        except Exception:
            return set()
    return set()

def _save_set(file: Path, s: set):
    file.write_text(json.dumps(sorted(s), ensure_ascii=False), encoding="utf-8")

def load_bought() -> set:
    return _load_set(BOUGHT_FILE)

def save_bought(s: set):
    _save_set(BOUGHT_FILE, s)

def load_seen() -> set:
    return _load_set(SEEN_FILE)

def save_seen(s: set):
    _save_set(SEEN_FILE, s)

def looks_premium(title:str, badge:str)->bool:
    t = (title or "").lower()
    b = (badge or "").lower()
    return any(w in t for w in PREMIUM_WORDS) or any(w in b for w in PREMIUM_WORDS)

async def has_colored_border(card) -> bool:
    # –≠–≤—Ä–∏—Å—Ç–∏–∫–∞ "—Ü–≤–µ—Ç–Ω–∞—è –æ–±–≤–æ–¥–∫–∞": –Ω–µ —Å–µ—Ä—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã/—Ç–µ–Ω–∏
    try:
        elem = card.locator(CARD_FRAME).first
        if await elem.count() == 0:
            elem = card
        color = await elem.evaluate("""(el)=>{
            const s = getComputedStyle(el);
            return (s.borderColor || s.outlineColor || s.boxShadow || '').toString();
        }""")
        if not color:
            return False
        color = color.lower()
        if "transparent" in color or "none" == color.strip():
            return False
        m = re.search(r"rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)", color)
        if m:
            r,g,b = map(int, m.groups())
            # true –µ—Å–ª–∏ –Ω–µ —Å–µ—Ä—ã–π (r‚âàg‚âàb ‚Äî —Å–µ—Ä—ã–π)
            return not (abs(r-g)<8 and abs(g-b)<8 and abs(r-b)<8)
        m = re.search(r"#([0-9a-f]{6})", color)
        if m:
            hv = m.group(1); r=int(hv[0:2],16); g=int(hv[2:4],16); b=int(hv[4:6],16)
            return not (abs(r-g)<8 and abs(g-b)<8 and abs(r-b)<8)
        return "rgba(" in color or "box-shadow" in color or "inset" in color
    except:
        return False

# ===== Playwright —à–∞–≥–∏ =====
async def ensure_login(context):
    page = await context.new_page()
    await page.goto("https://web.telegram.org/k/", wait_until="networkidle")
    if "login" in page.url or "auth" in page.url:
        LOG.info("–û—Ç–∫—Ä–æ–π –±—Ä–∞—É–∑–µ—Ä –∏ –∑–∞–ª–æ–≥–∏–Ω—å—Å—è (QR/–∫–æ–¥). –°–∫—Ä–∏–ø—Ç –∂–¥—ë—Ç‚Ä¶")
        await page.wait_for_url(re.compile(r".*/k/.*"), timeout=0)
        await context.storage_state(path=STORAGE)
        LOG.info("–°–µ—Å—Å–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: %s", STORAGE)
    else:
        LOG.info("–ù–∞–π–¥–µ–Ω–∞ –∞–∫—Ç–∏–≤–Ω–∞—è —Å–µ—Å—Å–∏—è Telegram Web.")
    await page.close()

async def open_gifts_webapp(page: Page) -> Frame:
    await page.goto(GIFT_ENTRY_URL, wait_until="domcontentloaded")
    # –õ–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ "Open"
    for text in ("Open", "–û—Ç–∫—Ä—ã—Ç—å"):
        try:
            await page.get_by_text(text).click(timeout=2500)
            break
        except:
            pass
    await page.wait_for_timeout(1200)
    frames = [f for f in page.frames if f != page.main_frame]
    return frames[-1] if frames else page.main_frame

async def enter_catalog(webview: Frame):
    # –®–∞–≥–∏: –û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–¥–∞—Ä–æ–∫ -> –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–µ–±–µ
    try:
        if await webview.locator(ENTRY_SEND_GIFT).count():
            await webview.locator(ENTRY_SEND_GIFT).first.click()
            await webview.wait_for_timeout(350)
    except:
        pass
    try:
        if await webview.locator(ENTRY_SEND_TO_SELF).count():
            await webview.locator(ENTRY_SEND_TO_SELF).first.click()
            await webview.wait_for_timeout(500)
    except:
        pass

async def refresh_app(webview: Frame):
    try:
        if await webview.locator(ALL_TAB).count():
            await webview.locator(ALL_TAB).first.click()
            await webview.wait_for_timeout(350)
    except:
        pass

async def scan_and_buy(webview: Frame, bought_titles:set, seen_gifts:set,
                       max_buys:int, client: TelegramClient) -> int:
    """
    –°–∫–∞–Ω–∏—Ä—É–µ–º –∫–∞—Ç–∞–ª–æ–≥:
      ‚Ä¢ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –õ–Æ–ë–´–• –Ω–æ–≤—ã—Ö –∫–∞—Ä—Ç–æ—á–∫–∞—Ö (seen_gifts)
      ‚Ä¢ –ø–æ–∫—É–ø–∞–µ–º –ø—Ä–µ–º–∏—É–º –¥–æ max_buys
    """
    buys = 0
    new_notified = 0

    cards = await webview.locator(CARD_ITEM).all()
    LOG.info("–ö–∞—Ä—Ç–æ—á–µ–∫ –Ω–∞ —ç–∫—Ä–∞–Ω–µ: %d", len(cards))

    for card in cards:
        # –∑–∞–≥–æ–ª–æ–≤–æ–∫/–±–µ–π–¥–∂ ‚Äî –º–æ–≥—É—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å
        title = badge = ""
        try:
            if await card.locator(CARD_TITLE).count():
                title = (await card.locator(CARD_TITLE).first.inner_text()).strip()
            if await card.locator(CARD_BADGE).count():
                badge = (await card.locator(CARD_BADGE).first.inner_text()).strip()
        except:
            pass

        # —É—Å—Ç–æ–π—á–∏–≤—ã–π –∫–ª—é—á –∫–∞—Ä—Ç–æ—á–∫–∏
        try:
            html_snip = await card.evaluate('(e)=>e.outerHTML')
        except:
            html_snip = ""
        key = (title or f"html:{html_snip.strip()[:96]}")

        # ----- —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –õ–Æ–ë–û–ú –Ω–æ–≤–æ–º –ø–æ–¥–∞—Ä–∫–µ -----
        if key not in seen_gifts and new_notified < NEW_NOTIFY_LIMIT:
            try:
                await client.send_message("me", f"üÜï –ù–æ–≤—ã–π –ø–æ–¥–∞—Ä–æ–∫ –æ–±–Ω–∞—Ä—É–∂–µ–Ω: {title or '(–±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è)'}")
            except Exception as e:
                LOG.warning("–ù–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–æ—Å—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–æ–≤–æ–º –ø–æ–¥–∞—Ä–∫–µ: %s", e)
            seen_gifts.add(key); save_seen(seen_gifts)
            new_notified += 1

        # ----- –ø—Ä–µ–º–∏—É–º‚Äë–¥–µ—Ç–µ–∫—Ç –∏ –ø–æ–∫—É–ø–∫–∞ -----
        is_premium = looks_premium(title, badge)
        if not is_premium:
            is_premium = await has_colored_border(card)
        if not is_premium:
            continue

        if key in bought_titles:
            continue

        LOG.info("üîé –ü—Ä–µ–º–∏—É–º: %r / %r", title, badge)

        # –æ—Ç–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É
        try:
            await card.click()
        except Exception as e:
            LOG.warning("–ù–µ –∫–ª–∏–∫–Ω—É–ª–æ—Å—å: %s", e); continue

        # —à–∞–≥ 1: –∫–Ω–æ–ø–∫–∞ –ø–æ–∫—É–ø–∫–∏ –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–µ
        try:
            await webview.locator(BUY_BTN_LIST).first.click(timeout=5000)
        except Exception as e:
            LOG.warning("–ù–µ—Ç –∫–Ω–æ–ø–∫–∏ '–ö—É–ø–∏—Ç—å/–û—Ç–ø—Ä–∞–≤–∏—Ç—å' –Ω–∞ 1-–º —ç–∫—Ä–∞–Ω–µ: %s", e)
            try: await webview.go_back()
            except: pass
            continue

        # —à–∞–≥ 2: –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ ‚Äî '–û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–¥–∞—Ä–æ–∫'
        try:
            btn = webview.locator(CONFIRM_BUY_BTN).first
            await btn.wait_for(timeout=6000)
            price_txt = (await btn.inner_text()).strip()
            await btn.click()
            LOG.info("‚úÖ –ö—É–ø–ª–µ–Ω–æ: %s (%s)", key, price_txt)
            bought_titles.add(key); save_bought(bought_titles)
            try:
                await client.send_message("me", f"‚úÖ –ö—É–ø–ª–µ–Ω –ø–æ–¥–∞—Ä–æ–∫: {title or key} {('('+price_txt+')') if price_txt else ''}")
            except Exception as e:
                LOG.warning("–ù–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–æ—Å—å –≤ '–ò–∑–±—Ä–∞–Ω–Ω–æ–µ': %s", e)

            buys += 1
            if buys >= max_buys: break
            await asyncio.sleep(1.0 + random.random()*0.7)
        except Exception as e:
            LOG.warning("–ù–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª –ø–æ–∫—É–ø–∫—É: %s", e)
            try: await webview.go_back()
            except: pass

    return buys

# ===== –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª =====
async def worker_loop():
    bought_titles = load_bought()
    seen_gifts = load_seen()

    # Telethon ‚Äî –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –≤ "–ò–∑–±—Ä–∞–Ω–Ω–æ–µ" (user‚Äë—Å–µ—Å—Å–∏—è)
    client = TelegramClient(SESSION, API_ID, API_HASH)
    await client.start()  # –ø–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫ —Å–ø—Ä–æ—Å–∏—Ç –∫–æ–¥/2FA

    async with async_playwright() as p:
        # —Ñ–ª–∞–≥–∏ –¥–ª—è VPS
        browser = await p.chromium.launch(
            headless=True,
            args=["--no-sandbox", "--disable-dev-shm-usage"]
        )
        context = await browser.new_context(
            storage_state=STORAGE if Path(STORAGE).exists() else None
        )
        await ensure_login(context)

        while True:
            page = await context.new_page()
            try:
                LOG.info("–û—Ç–∫—Ä—ã–≤–∞—é –º–∏–Ω–∏‚Äë–∞–ø–ø‚Ä¶")
                webview = await open_gifts_webapp(page)
                await enter_catalog(webview)
                await refresh_app(webview)
                bought_now = await scan_and_buy(webview, bought_titles, seen_gifts,
                                                MAX_BUYS_PER_CYCLE, client)
                LOG.info("–¶–∏–∫–ª –∑–∞–≤–µ—Ä—à—ë–Ω: –∫—É–ø–ª–µ–Ω–æ %d", bought_now)
            except Exception as e:
                LOG.error("–°–±–æ–π —Ü–∏–∫–ª–∞: %s", e)
            finally:
                try: await page.close()
                except: pass

            await asyncio.sleep(CHECK_INTERVAL)

async def main_forever():
    # –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ –≤–æ—Ä–∫–µ—Ä–∞ –ø—Ä–∏ –ª—é–±—ã—Ö —Ñ–∞—Ç–∞–ª—å–Ω—ã—Ö —Å–±–æ—è—Ö
    while True:
        try:
            await worker_loop()
        except Exception as e:
            LOG.error("Worker —É–ø–∞–ª, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—é —á–µ—Ä–µ–∑ 5—Å: %s", e)
            await asyncio.sleep(5)

if __name__ == "__main__":
    for sig in (signal.SIGINT, signal.SIGTERM):
        signal.signal(sig, signal.SIG_DFL)
    asyncio.run(main_forever())
